// полиморфная функция - функция, поведение которой зависит от типа
// аргумента, переданного ей. 
// Перегрузки функции - полиморфная функция.

// Шаблонная функция может не быть полиморфной, если шаблонный тип не является частью сигнатуры. 

// virtual функция всегда полиморвна из-за неявного аргумента this.


//-------------------------------------------
// проектирование - моделирование между типами.


//----------------------------------------------------------------------
//----------------------------------------------------------------------
//----------------------Отношения между классами------------------------
//----------------------------------------------------------------------
//----------------------------------------------------------------------

//-------------------------------------------
// ассоциация 

// Сущности  каким-то образом связанны.

/* 

    Ассоциация в объектно-ориентированном программировании представляет собой
    связь между двумя классами, когда один класс использует другой, но при этом
    ни один из них не владеет другим. 

 */

class Book;

class Professor {
    ....
    std::vectro<Book*> books;
};

class Book {
    ....

    Author* author;
};


//-------------------------------------------
// генерализация  
// онтношение частное/общее, открытое наследование

// мнемоническое правило - широкий конец к более широкому 
// Derived ----> Base

class IMatrix {
    virtual ~IMatrix() {}
}; 

class Matrix : public IMatrix { .... };

class LazyMatrix : public IMatrix { .... };




//-------------------------------------------
// Композиция
// B является частью A.
// А и B связанны временнем жизни (умирает A - умирает B).


class File; 

class Folder {
    std::vector<File> content; 
};
// Файл принадлежит только одной папке
// и связан с ней временем жизни.

// Файл тут - Композит.

//-------------------------------------------
// Аггрегация
// Сущность A владеет сущностью B, но у B могут быть еще владельцы. 

class Segment; // Отрезок может быть частью многих треугольников.

class Triangle {
    ....
    stt::vector<Segment*> segments; 
};

Segment s1, s2, s3; // Отрезок может жить дольше, чем какой-то треугольник.
// отрезок тут - Агрегат.

Triangle t1(s1, s2, s3);
Triangle t2(s1, s2, s3);